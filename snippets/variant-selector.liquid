{%- if product.has_only_default_variant -%}
  <input name="id" value="{{ product.selected_or_first_available_variant.id }}" hidden>
{%- else -%}
  <select name="id" hidden>
    {%- for variant in product.variants -%}
      <option
        value="{{ variant.id }}"
        {% if variant == product.selected_or_first_available_variant %}selected{% endif %}
        {% if variant.option1 %}data-option1="{{ variant.option1 }}"{% endif %}
        {% if variant.option2 %}data-option2="{{ variant.option2 }}"{% endif %}
        {% if variant.option3 %}data-option3="{{ variant.option3 }}"{% endif %}
      >
        {{ variant | json }}
      </option>
    {%- endfor -%}
  </select>

  <div class="grid gap-6 py-4 bg-white rounded-[400px]">
    {%- for product_option in product.options_with_values -%}
      <fieldset class="mb-4">
        <legend class="text-sm font-medium text-white mb-2">{{ product_option.name }}</legend>
        <div class="flex flex-wrap gap-2 fest transition-colors duration-300">
          {%- for value in product_option.values -%}
           <label class="cursor-pointer">
              <input
                class="hidden peer"
                name="option{{ product_option.position }}"
                value="{{ value }}"
                type="radio"
                {% if product_option.selected or forloop.index0 == 0 %}checked{% endif %}
              />
              <span class="block px-4 py-2 rounded-[400px] text-sm transition-all hover:bg-white/20 peer-checked:hover:bg-white">
                {{ value }}
              </span>
           </label>
          {%- endfor -%}
        </div>
      </fieldset>
    {%- endfor -%}
  </div>
{%- endif -%}

<style>
  .fest {
    width: fit-content;
    padding: 5px;
    border-radius: 400px;
  }
  fieldset { outline: none; margin: 0; padding: 0; }
  label span { transition: all 0.2s ease; }
  label:hover span { border-color: black; }
</style>

<script>
  document.addEventListener("DOMContentLoaded", function() {
    // Function to update the hidden select based on checked radio inputs
    function updateVariant() {
      const option1 = document.querySelector('input[name="option1"]:checked')?.value || "";
      const option2 = document.querySelector('input[name="option2"]:checked')?.value || "";
      const option3 = document.querySelector('input[name="option3"]:checked')?.value || "";

      const select = document.querySelector('select[name="id"]');
      if (select) {
        Array.from(select.options).forEach(option => {
          let match = true;
          if (option.dataset.option1 && option.dataset.option1 !== option1) match = false;
          if (option.dataset.option2 && option.dataset.option2 !== option2) match = false;
          if (option.dataset.option3 && option.dataset.option3 !== option3) match = false;
          if (match) {
            option.selected = true;
          }
        });
      }
    }
    
    // Update visual styles and variant sync
    function updateContainer(container) {
      const checkedInput = container.querySelector('input[type="radio"]:checked');
      if (checkedInput) {
        let value = checkedInput.value.toLowerCase().trim().replace(/\s+/g, '-');
        const newBgClass = `bg-${value}-500`;
        container.classList.forEach(cls => {
          if (/^bg-\S+/.test(cls)) container.classList.remove(cls);
        });
        container.classList.add(newBgClass);
        if (value === 'white') container.classList.add('outline', 'outline-black');
        else container.classList.remove('outline', 'outline-black');
        
        container.querySelectorAll('label').forEach(label => {
          const radio = label.querySelector('input[type="radio"]');
          const span = label.querySelector('span');
          if (radio.checked) {
            span.classList.add('text-black');
            span.classList.remove('text-black/80');
            if (value === 'white') {
              span.classList.add('outline', 'outline-black');
              span.classList.remove('bg-white');
            } else {
              span.classList.remove('outline', 'outline-black');
              span.classList.add('bg-white');
            }
          } else {
            span.classList.add('text-black/80');
            span.classList.remove('text-black', 'bg-white', 'outline', 'outline-black');
          }
        });
      }
      updateVariant();
    }
    
    // Bind change event for all radio buttons within each container
    const festContainers = document.querySelectorAll('.fest');
    festContainers.forEach(container => {
      const radios = container.querySelectorAll('input[type="radio"]');
      radios.forEach(radio => radio.addEventListener('change', function() {
        updateContainer(container);
      }));
      // Initialize on page load
      updateContainer(container);
    });
    
    // Ensure hidden select is updated on load
    updateVariant();
  });
</script>
